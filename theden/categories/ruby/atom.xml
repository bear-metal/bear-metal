<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | Bear Metal]]></title>
  <link href="http://bearmetal.eu/theden/categories/ruby/atom.xml" rel="self"/>
  <link href="http://bearmetal.eu/"/>
  <updated>2015-01-07T08:58:33+02:00</updated>
  <id>http://bearmetal.eu/</id>
  <author>
    <name><![CDATA[Bear Metal OÜ]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How to install Ruby 2.2.0 on OS X Yosemite with Homebrew and rbenv]]></title>
    <link href="http://bearmetal.eu/theden/install-ruby-2-dot-2-0-yosemite-openssl-error/"/>
    <updated>2015-01-06T16:15:00+02:00</updated>
    <id>http://bearmetal.eu/theden/install-ruby-2-dot-2-0-yosemite-openssl-error</id>
    <content type="html"><![CDATA[<p>When trying to install Ruby 2.2.0 on Yosemite with <a href="https://github.com/sstephenson/rbenv">rbenv</a> and <a href="http://brew.sh">Homebrew</a>, I got a weird error:</p>

<p>```
➜  ~ ✗ rbenv install 2.2.0
Downloading ruby-2.2.0.tar.gz…
-&gt; http://dqw8nmjcqpjn7.cloudfront.net/7671e394abfb5d262fbcd3b27a71bf78737c7e9347fa21c39e58b0bb9c4840fc
Installing ruby-2.2.0…</p>

<p>BUILD FAILED (OS X 10.10.1 using ruby-build 20141225)</p>

<p>Inspect or clean up the working tree at /var/folders/s<em>/_zh3skrd0qz2933nns5y425r0000gn/T/ruby-build.20150106151200.81466
Results logged to /var/folders/s</em>/_zh3skrd0qz2933nns5y425r0000gn/T/ruby-build.20150106151200.81466.log</p>

<p>Last 10 log lines:
make[2]: <em>** Waiting for unfinished jobs….
compiling raddrinfo.c
compiling ifaddr.c
make[1]: **</em> [ext/openssl/all] Error 2
make[1]: <em>** Waiting for unfinished jobs….
linking shared-object zlib.bundle
linking shared-object socket.bundle
linking shared-object date_core.bundle
linking shared-object ripper.bundle
make: **</em> [build-ext] Error 2
```</p>

<p>When I opened up the log file mentioned in the output above, I could see the actual cause of the error:</p>

<p>```
ossl_ssl.c:125:5: error: use of undeclared identifier ‘TLSv1<em>2_method’
    OSSL_SSL_METHOD_ENTRY(TLSv1</em>2),
    ^
ossl_ssl.c:119:69: note: expanded from macro ‘OSSL_SSL_METHOD_ENTRY’
#define OSSL_SSL_METHOD_ENTRY(name) { #name, (SSL_METHOD <em>(</em>)(void))name##_method }
                                                                    ^
<scratch space="">:148:1: note: expanded from here
TLSv1_2_method</scratch></p>
<p>ossl_ssl.c:126:5: error: use of undeclared identifier ‘TLSv1<em>2_server_method’
    OSSL_SSL_METHOD_ENTRY(TLSv1</em>2_server),
    ^
ossl_ssl.c:119:69: note: expanded from macro ‘OSSL_SSL_METHOD_ENTRY’
#define OSSL_SSL_METHOD_ENTRY(name) { #name, (SSL_METHOD <em>(</em>)(void))name##_method }
                                                                    ^
<scratch space="">:148:1: note: expanded from here
TLSv1_2_server_method</scratch></p>
<p>ossl_ssl.c:127:5: error: use of undeclared identifier ‘TLSv1<em>2_client_method’
    OSSL_SSL_METHOD_ENTRY(TLSv1</em>2_client),
    ^
ossl_ssl.c:119:69: note: expanded from macro ‘OSSL_SSL_METHOD_ENTRY’
#define OSSL_SSL_METHOD_ENTRY(name) { #name, (SSL_METHOD <em>(</em>)(void))name##_method }
                                                                    ^
<scratch space="">:148:1: note: expanded from here
TLSv1_2_client_method</scratch></p>
<p>ossl_ssl.c:131:5: error: use of undeclared identifier ‘TLSv1<em>1_method’
    OSSL_SSL_METHOD_ENTRY(TLSv1</em>1),
    ^
ossl_ssl.c:119:69: note: expanded from macro ‘OSSL_SSL_METHOD_ENTRY’
#define OSSL_SSL_METHOD_ENTRY(name) { #name, (SSL_METHOD <em>(</em>)(void))name##_method }
                                                                    ^
<scratch space="">:148:1: note: expanded from here
TLSv1_1_method</scratch></p>
<p>ossl_ssl.c:132:5: error: use of undeclared identifier ‘TLSv1<em>1_server_method’
    OSSL_SSL_METHOD_ENTRY(TLSv1</em>1_server),
    ^
ossl_ssl.c:119:69: note: expanded from macro ‘OSSL_SSL_METHOD_ENTRY’
#define OSSL_SSL_METHOD_ENTRY(name) { #name, (SSL_METHOD <em>(</em>)(void))name##_method }
                                                                    ^
<scratch space="">:148:1: note: expanded from here
TLSv1_1_server_method</scratch></p>
<p>ossl_ssl.c:133:5: error: use of undeclared identifier ‘TLSv1<em>1_client_method’
    OSSL_SSL_METHOD_ENTRY(TLSv1</em>1_client),
    ^
ossl_ssl.c:119:69: note: expanded from macro ‘OSSL_SSL_METHOD_ENTRY’
#define OSSL_SSL_METHOD_ENTRY(name) { #name, (SSL_METHOD <em>(</em>)(void))name##_method }
                                                                    ^
<scratch space="">:148:1: note: expanded from here
TLSv1_1_client_method</scratch></p>
<p>ossl_ssl.c:210:21: error: invalid application of ‘sizeof’ to an incomplete type ‘const struct <anonymous struct="" at="" ossl_ssl.c:115:14=""> []'
    for (i = 0; i &lt; numberof(ossl_ssl_method_tab); i++) {
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ossl_ssl.c:19:35: note: expanded from macro 'numberof'
#define numberof(ary) (int)(sizeof(ary)/sizeof((ary)[0]))
                                  ^~~~~
ossl_ssl.c:1127:13: warning: using the result of an assignment as a condition without parentheses [-Wparentheses]
            if (rc = SSL_shutdown(ssl))
                ~~~^~~~~~~~~~~~~~~~~~~
ossl_ssl.c:1127:13: note: place parentheses around the assignment to silence this warning
            if (rc = SSL_shutdown(ssl))
                   ^
                (                     )
ossl_ssl.c:1127:13: note: use '==' to turn this assignment into an equality comparison
            if (rc = SSL_shutdown(ssl))
                   ^
                   ==
ossl_ssl.c:2194:23: error: invalid application of 'sizeof' to an incomplete type 'const struct <anonymous struct="" at="" ossl_ssl.c:115:14=""> []'
    ary = rb_ary_new2(numberof(ossl_ssl_method_tab));
                      ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ossl_ssl.c:19:35: note: expanded from macro 'numberof'
#define numberof(ary) (int)(sizeof(ary)/sizeof((ary)[0]))
                                  ^~~~~
ossl_ssl.c:2195:21: error: invalid application of 'sizeof' to an incomplete type 'const struct <anonymous struct="" at="" ossl_ssl.c:115:14=""> []'
    for (i = 0; i &lt; numberof(ossl_ssl_method_tab); i++) {
                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
ossl_ssl.c:19:35: note: expanded from macro 'numberof'
#define numberof(ary) (int)(sizeof(ary)/sizeof((ary)[0]))
                                  ^~~~~
1 warning and 9 errors generated.
make[2]: *** [ossl_ssl.o] Error 1
make[2]: *** Waiting for unfinished jobs....
compiling raddrinfo.c
compiling ifaddr.c
make[1]: *** [ext/openssl/all] Error 2
make[1]: *** Waiting for unfinished jobs....
linking shared-object zlib.bundle
linking shared-object socket.bundle
linking shared-object date_core.bundle
linking shared-object ripper.bundle
make: *** [build-ext] Error 2
```</anonymous></anonymous></anonymous></p>

<p>The weird thing here is that I did not get the usual ‘Missing the OpenSSL lib?’ warning. The lib <em>was</em> found but somehow the headers were fucked up. It also did not happen with older rbenv Rubies.</p>

<p>Thanks to <a href="https://bearmetal.eu/team/tarmo/">Tarmo</a> I found the solution <a href="https://issues.apache.org/jira/browse/THRIFT-2515?focusedCommentId=14012758&amp;page=com.atlassian.jira.plugin.system.issuetabpanels:comment-tabpanel#comment-14012758">here</a>.</p>

<p>What I had to do was this:</p>

<p><code>
➜  ~  brew update
➜  ~  brew install openssl
➜  ~  /usr/local/opt/openssl/bin/c_rehash
</code></p>

<p>Now make sure that your new binary is in your PATH before the system one.</p>

<p><code>
➜  ~  ln -s /usr/local/opt/openssl/bin/openssl /usr/local/bin/openssl
➜  ~ which openssl
/usr/bin/openssl
➜  ~ echo $PATH
/usr/local/heroku/bin:/Users/jarkko/.rbenv/shims:/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin
</code></p>

<p>That’s no good. Let’s fix our PATH. I’m using zsh, so for me it’s set in <code>~/.zshrc</code>. Your particular file depends on the shell you’re using (for bash it would be <code>~/.bashrc</code> or <code>~/.bash_profile</code>, but see the caveat <a href="http://www.joshstaiger.org/archives/2005/07/bash_profile_vs.html">here</a>).</p>

<p><code>
➜  ~ vim ~/.zshrc
# Change the line that sets PATH so that /usr/local/bin
# comes BEFORE /usr/bin. For me, it looks like this:
# export PATH=/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin
</code></p>

<p>Open up a new terminal window and check that the PATH is correct:</p>

<p><code>
➜  ~  echo $PATH
/usr/local/heroku/bin:/Users/jarkko/.rbenv/shims:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin
➜  ~  which openssl
/usr/local/bin/openssl
</code></p>

<p>Better. Now, let’s make sure that homebrew libs symlink to the newer openssl.</p>

<p>```
➜  ~  brew unlink openssl
➜  ~  brew link –overwrite –force openssl
➜  ~  openssl version -a</p>

<p>OpenSSL 1.0.1j 15 Oct 2014
built on: Sun Dec  7 02:14:31 GMT 2014
platform: darwin64-x86<em>64-cc
options:  bn(64,64) rc4(ptr,char) des(idx,cisc,16,int) idea(int) blowfish(idx) 
compiler: clang -fPIC -fno-common -DOPENSSL_PIC -DZLIB_SHARED -DZLIB -DOPENSSL_THREADS -D_REENTRANT -DDSO_DLFCN -DHAVE_DLFCN_H -arch x86</em>64 -O3 -DL_ENDIAN -Wall -DOPENSSL_IA32_SSE2 -DOPENSSL_BN_ASM_MONT -DOPENSSL_BN_ASM_MONT5 -DOPENSSL_BN_ASM_GF2m -DSHA1_ASM -DSHA256_ASM -DSHA512_ASM -DMD5_ASM -DAES_ASM -DVPAES_ASM -DBSAES_ASM -DWHIRLPOOL_ASM -DGHASH_ASM
OPENSSLDIR: “/usr/local/etc/openssl”
```</p>

<p>Splendid.</p>

<p>After that, Ruby 2.2.0 installed cleanly without any specific parameters needed:</p>

<p><code>
➜  ~  rbenv install 2.2.0
Downloading ruby-2.2.0.tar.gz...
-&gt; http://dqw8nmjcqpjn7.cloudfront.net/7671e394abfb5d262fbcd3b27a71bf78737c7e9347fa21c39e58b0bb9c4840fc
Installing ruby-2.2.0...
Installed ruby-2.2.0 to /Users/jarkko/.rbenv/versions/2.2.0
</code></p>

<p><strong>[UPDATE 1, Jan 7]</strong> The original version of this post told you to <code>rm /usr/bin/openssl</code>, based on the link above. As James Tucker pointed out, this is a horrible idea. I fixed the article so that we now fix the <code>$PATH</code> instead.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails Garbage Collection: age matters]]></title>
    <link href="http://bearmetal.eu/theden/rails-garbage-collection-age-matters/"/>
    <updated>2014-12-22T20:26:00+02:00</updated>
    <id>http://bearmetal.eu/theden/rails-garbage-collection-age-matters</id>
    <content type="html"><![CDATA[<p>In a <a href="https://bearmetal.eu/theden/rails-garbage-collection-naive-defaults/">previous post</a> in the <a href="/theden/categories/rails-performance">Rails Performance</a> series we stated that the default garbage collection settings for <a href="http://www.rubyonrails.org">Ruby on Rails</a> applications are not optimal. In this post we’ll explore the basics of object age in RGenGC, Ruby 2.1’s new <em>restricted generational garbage collector</em>.</p>

<p>As a prerequisite of this and subsequent posts, basic understanding of a <em>mark and sweep</em><sup id="fnref:marksweep"><a href="#fn:marksweep" rel="footnote">1</a></sup> collector is assumed.</p>

<p><img src="/images/gc_mark_sweep.png" alt="" /></p>

<p>A somewhat simplified mark and sweep cycle goes like this:</p>

<ol>
  <li>A mark and sweep collector traverses the object graph.</li>
  <li>It checks which objects are in use (referenced) and which ones are not.</li>
  <li>This is called object marking, aka. the <strong>MARK PHASE</strong>.</li>
  <li>All unused objects are freed, making their memory available.</li>
  <li>This is called sweeping, aka. the <strong>SWEEP PHASE</strong>.</li>
  <li>Nothing changes for used objects.</li>
</ol>

<p>A GC cycle prior to Ruby 2.1 works like that. A typical Rails app boots with 300 000 live objects of which all need to be scanned during the <strong>MARK</strong> phase. That usually yields a smaller set to <strong>SWEEP</strong>.</p>

<p>A large percentage of the graph is going to be traversed over and over again but will never be reclaimed. This is not only CPU intensive during GC cycles, but also incurs memory overhead for accounting and anticipation for future growth.</p>

<h2 id="old-and-young-objects">Old and young objects</h2>

<p><strong>What generally makes an object old?</strong></p>

<ul>
  <li><em>All new objects are considered to be young</em>.</li>
  <li><em>Old objects survived at least one GC cycle (major or minor)</em> The collector thus reasons that the object will stick around and not become garbage quickly.</li>
</ul>

<p>The idea behind the new generational garbage collector is this:</p>

<blockquote>
  <p><strong>MOST OBJECTS DIE YOUNG.</strong></p>
</blockquote>

<p>To take advantage of this fact, the new GC classifies objects on the Ruby heap as either <strong>OLD</strong> or <strong>YOUNG</strong>. This segregation now allows the garbage collector to work with two distinct generations, with the <strong>OLD</strong> generation much less likely to yield much improvement towards recovering memory.</p>

<p>For a typical Rails request, some examples of old and new objects would be:</p>

<ul>
  <li><strong>Old:</strong> compiled routes, templates, ActiveRecord connections, cached DB column info, classes, modules etc.</li>
  <li><strong>New:</strong> short lived strings within a partial, a string column value from an ActiveRecord result, a coerced DateTime instance etc.</li>
</ul>

<p>Young objects are more likely to reference old objects than old objects referencing young objects. Old objects also frequently reference other old objects.</p>

<p><code>ruby
  u = User.first
  #&lt;User id: 1, email: "lourens@something.com", encrypted_password: "blahblah...", reset_password_token: nil, reset_password_sent_at: nil, remember_created_at: nil, sign_in_count: 2, current_sign_in_at: "2014-10-31 11:52:30", last_sign_in_at: "2014-10-29 10:04:01", current_sign_in_ip: "127.0.0.1", last_sign_in_ip: "127.0.0.1", created_at: "2014-10-29 10:04:01", updated_at: "2014-11-30 14:07:15", provider: nil, uid: nil, first_name: "dfdsfds", last_name: "dfdsfds", confirmation_token: nil, confirmed_at: "2014-10-30 10:11:42", confirmation_sent_at: nil, unconfirmed_email: nil, onboarded_at: nil&gt;
</code></p>

<p>Notice how the transient attribute keys and names reference the long lived columns here:</p>

<p><code>ruby
	{"id"=&gt;
	   #&lt;ActiveRecord::ConnectionAdapters::PostgreSQLAdapter::OID::Integer:0x007fbe756d1d30&gt;,
	  "email"=&gt;
	   #&lt;ActiveRecord::ConnectionAdapters::PostgreSQLAdapter::OID::Identity:0x007fbe756d1718&gt;,
	  "encrypted_password"=&gt;
	   #&lt;ActiveRecord::ConnectionAdapters::PostgreSQLAdapter::OID::Identity:0x007fbe756d1718&gt;,
	  "reset_password_token"=&gt;
	   #&lt;ActiveRecord::ConnectionAdapters::PostgreSQLAdapter::OID::Identity:0x007fbe756d1718&gt;,
	  "reset_password_sent_at"=&gt;
	   #&lt;ActiveRecord::AttributeMethods::TimeZoneConversion::Type:0x007fbe741f63c0
	    @column=
	     #&lt;ActiveRecord::ConnectionAdapters::PostgreSQLAdapter::OID::Timestamp:0x007fbe756d0e58&gt;&gt;,
</code></p>

<p>Age segregation is also just a classification – old and young objects aren’t stored in distinct memory spaces – they’re just conceptional buckets. The generation of an object refers to the amount of GC cycles it survived:</p>

<p><code>ruby
irb(main):009:0&gt; ObjectSpace.dump([])
=&gt; "{\"address\":\"0x007fd24c007668\", \"type\":\"ARRAY\", \"class\":\"0x007fd24b872038\", \"length\":0, \"file\":\"(irb)\", \"line\":9, \"method\":\"irb_binding\", \"generation\":8, \"flags\":{\"wb_protected\":true}}\n"
irb(main):010:0&gt; GC.count
=&gt; 8
</code></p>

<h2 id="what-the-heck-is-major-and-minor-gc">What the heck is major and minor GC?</h2>

<p>You may have heard, read about or noticed in GC.stat output the terms “minor” and “major” GC.</p>

<p><code>ruby
	irb(main):003:0&gt; pp GC.stat
	{:count=&gt;32,
	 :heap_used=&gt;1181,
	 :heap_length=&gt;1233,
	 :heap_increment=&gt;50,
	 :heap_live_slot=&gt;325148,
	 :heap_free_slot=&gt;156231,
	 :heap_final_slot=&gt;0,
	 :heap_swept_slot=&gt;163121,
	 :heap_eden_page_length=&gt;1171,
	 :heap_tomb_page_length=&gt;10,
	 :total_allocated_object=&gt;2050551,
	 :total_freed_object=&gt;1725403,
	 :malloc_increase=&gt;1462784,
	 :malloc_limit=&gt;24750208,
	 :minor_gc_count=&gt;26,
	 :major_gc_count=&gt;6,
	 :remembered_shady_object=&gt;3877,
	 :remembered_shady_object_limit=&gt;4042,
	 :old_object=&gt;304270,
	 :old_object_limit=&gt;259974,
	 :oldmalloc_increase=&gt;23639792,
	 :oldmalloc_limit=&gt;24159190}
</code></p>

<p><strong>Minor GC (or “partial marking”):</strong> This cycle only traverses the young generation and is very fast. Based on the hypothesis that most objects die young, this GC cycle is thus the most effective at reclaiming back a large ratio of memory in proportion to objects traversed.</p>

<p>It runs quite often - 26 times for the GC dump of a booted Rails app above.</p>

<p><strong>Major GC:</strong> Triggered by out-of-memory conditions - Ruby heap space needs to be expanded (not OOM killer! :-)) Both old and young objects are traversed and it’s thus significantly slower than a minor GC round. Generally when there’s a significant increase in old objects, a major GC would be triggered. Every major GC cycle that an object survived bumps its current generation.</p>

<p>It runs much less frequently - six times for the stats dump above.</p>

<p>The following diagram represents a minor GC cycle (<strong>MARK</strong> phase completed, <strong>SWEEP</strong> still pending) that identifies and promotes some objects to old.</p>

<p><img src="/images/gc_first_minor.png" alt="" /></p>

<p>A subsequent minor GC cycle (<strong>MARK</strong> phase completed, <strong>SWEEP</strong> still pending) ignores old objects during the mark phase.</p>

<p><img src="/images/gc_second_minor.png" alt="" /></p>

<p>Most of the reclaiming efforts are thus focussed on the young generation (new objects). Generally 95% of objects are dead by the first GC. The current generation of an object is the number of major GC cycles it has survived.</p>

<h2 id="rgengc">RGenGC</h2>

<p>At a very high level C Ruby 2.1’s collector has the following properties:</p>

<ul>
  <li>High throughput - it can sustain a high rate of allocations / collections due to faster minor GC cycles and very rare major GC cycles.</li>
  <li>GC pauses are still long (“stop the world”) for major GC cycles.</li>
  <li>Generational collectors have much shorter mark cycles as they traverse only the young generation, most of the time.</li>
</ul>

<p>This is a marked improvement to the C Ruby GC and serves as a base for implementing other advanced features moving forward. Ruby 2.2 supports incremental GC and object ages beyond just old and new definitions. A major GC cycle in 2.1 still runs in a “stop the world” manner, whereas a more involved incremental implementation (Ruby 2.2) interleaves short steps of mark and sweep cycles between other VM operations.</p>

<h2 id="object-references">Object references</h2>

<p>In this simple example below we create a String array with three elements.</p>

<p><code>ruby
	irb(main):001:0&gt; require 'objspace'
	=&gt; true
	irb(main):002:0&gt; ObjectSpace.trace_object_allocations_start
	=&gt; nil
	irb(main):003:0&gt; ary = %w(a b c)
	=&gt; ["a", "b", "c"]
</code></p>

<p>Very much like a river flowing downstream, the array has knowledge of (a reference to) each of its String elements. On the contrary, the strings don’t have an awareness of (or references back to) the array container.</p>

<p><code>ruby
	irb(main):004:0&gt; ObjectSpace.dump(ary)
	=&gt; "{\"address\":\"0x007fd24b890fd8\", \"type\":\"ARRAY\", \"class\":\"0x007fd24b872038\", \"length\":3, \"embedded\":true, \"references\":[\"0x007fd24b891050\", \"0x007fd24b891028\", \"0x007fd24b891000\"], \"file\":\"(irb)\", \"line\":3, \"method\":\"irb_binding\", \"generation\":7, \"flags\":{\"wb_protected\":true}}\n"
	irb(main):004:0&gt; ObjectSpace.reachable_objects_from(ary)
	=&gt; [Array, "a", "b", "c"]
	irb(main):006:0&gt; ObjectSpace.reachable_objects_from(ary[1])
	=&gt; [String]
	irb(main):007:0&gt; ObjectSpace.dump(ary[1])
	=&gt; "{\"address\":\"0x007fd24b891028\", \"type\":\"STRING\", \"class\":\"0x007fd24b829658\", \"embedded\":true, \"bytesize\":1, \"value\":\"b\", \"encoding\":\"UTF-8\", \"file\":\"(irb)\", \"line\":3, \"method\":\"irb_binding\", \"generation\":7, \"flags\":{\"wb_protected\":true, \"old\":true, \"marked\":true}}\n"
</code></p>

<p>We stated earlier that:</p>

<p><strong>Young objects are more likely to reference old objects, than old objects referencing young objects. Old objects also frequently reference other old objects.</strong></p>

<p><em>However</em> it’s possible for old objects to reference new objects. What happens when old objects reference new ones?</p>

<p>Old objects with references to new objects are stored in a “remembered set”. The remembered set is a container of references from old objects to new objects and is a shortcut for preventing heap scans for finding such references.</p>

<h2 id="implications-for-rails">Implications for Rails</h2>

<p>As our friend Ezra used to say, “no code is faster than no code.” The same applies to automatic memory management. Every object allocation also has a variable recycle cost. Allocation generally is low overhead as it happens once, except for the use case where there are no free object slots on the Ruby heap and a major GC is triggered as a result.</p>

<p>A major drawback of this limited segregation of OLD vs YOUNG is that <strong>many transient objects are in fact promoted to old during large contexts such as a Rails request</strong>. These long lived objects eventually become unexpected “memory leaks”. These transient objects can be conceptually classified as of “medium lifetime” as they need to stick around for the duration of a request. There’s however a large probability that a minor GC would run during request lifetime, promoting young objects to old, effectively increasing their lifetime to well beyond the end of a request. This situation can only be revisited during a major GC which runs infrequently and sweeps both old and young objects.</p>

<p><strong>Each generation can be specifically tweaked, with the older generation being particularly important for balancing total process memory use with maintaining a minimal transient object set (young ones) per request. And subsequent too fast promotion from young to old generation.</strong></p>

<p><em>In our next post we will explore how you’d approach tuning the Ruby GC for Rails applications, balancing tradeoffs of speed and memory. Leave your email address below and we’ll let you know as soon as it’s posted.</em></p>

<div class="footnotes">
  <ol>
    <li id="fn:marksweep">
      <p>See the Ruby Hacking Guide’s <a href="https://ruby-hacking-guide.github.io/gc.html">GC chapter</a> for further context and nitty gritty details. I’d recommended scanning the content below the first few headings, until turned off by C.<a href="#fnref:marksweep" rel="reference">&#8617;</a></p>
    </li>
  </ol>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Does Rails Scale?]]></title>
    <link href="http://bearmetal.eu/theden/does-rails-scale/"/>
    <updated>2014-12-19T15:22:00+02:00</updated>
    <id>http://bearmetal.eu/theden/does-rails-scale</id>
    <content type="html"><![CDATA[<figure>
  <p><a href="https://www.flickr.com/photos/soctech/43279549/"><img src="https://farm1.staticflickr.com/24/43279549_465d50976e_b_d.jpg" alt="" /></a></p>

  <figcaption>
    <p>Photo by <a href="https://www.flickr.com/photos/soctech/43279549/">Soctech</a></p>
  </figcaption>
</figure>

<p>Back when Rails was still not mainstream, a common dismissal by developers using other – more established – technologies was that Rails is cool and stuff, but it will never scale<sup id="fnref:marketing"><a href="#fn:marketing" rel="footnote">1</a></sup>. While the question isn’t (compared to Rails’ success) as common these days, it still appears in one form or another every once in a while.</p>

<p>Last week on the Ruby on Rails Facebook group, someone asked <a href="https://www.facebook.com/groups/rubyandrails/permalink/10153620823655752/">this question</a>:</p>

<blockquote>
  <p>Can Rails stand up to making a social platform like FB with millions of users using it at the same time? </p>

  <p>If so what are the pro’s and the cons?</p>
</blockquote>

<p>So in other words, can Rails scale <em>a lot</em>?</p>

<p>Just as is customary for a Facebook group, the question got a lot of clueless answers. There were a couple of gems like this:</p>

<blockquote>
  <p>Tony if you want to build some thing like FB, you need to learn deeper mountable engine and SOLID anti pattern.</p>
</blockquote>

<p>The worst however are answers from people who <em>don’t know</em> they don’t know shit but insist on giving advice that is only bound to either confuse the original poster or lead them astray – and probably both:</p>

<blockquote>
  <p>Twitter is not a good example. They stopped using Rails because it couldn’t handle millions of request per second. They began using Scala.</p>
</blockquote>

<p>This is of course mostly BS with a hint of truth in it, but we’ll get back to that in a bit.</p>

<p>The issue with the question itself, is that <em>it’s the wrong question to ask</em>, and this has nothing to do with Ruby or Rails per se.</p>

<p>Why is it the wrong question? Let’s have a look.</p>

<p>Sure, Ruby is slow in raw performance. It has gotten a lot faster during the past decade, but it is still a highly dynamic interpreted scripting language. Its main shtick has always been programmer happiness, and its primary way to attain that goal has definitely not been to return from that test run as fast as possible. The same goes for Rails.</p>

<p>That said, there are two reasons bare Ruby performance doesn’t matter <em>that</em> much. First, it’s only a tiny part of the <strong>perceived app performance</strong> for the user. Rails has gone out of its way to automatically make the frontend of your web app performant. This includes frontend caching, asset pipeline, and more opinionated things like Turbolinks. You can of course screw all that up, but you would be amazed how much actual end-user performance you’d miss if you’d write the same app from scratch – not to mention the time you’d waste building it.</p>

<p>Second, and most important for this discussion: <strong>scaling is not the same thing as performance</strong>. Rails has always been built on the <a href="http://en.wikipedia.org/wiki/Shared_nothing_architecture">shared nothing architecture</a>, where in theory the only thing you need to do to scale out your app is to throw more hardware at it – the app should scale linearly. Of course there are limits to this, but they are by no means specific to Rails or Ruby.</p>

<p>Scaling and performance are two separate things. They are related as terms, but not strictly connected. Your app can be very fast for a couple users but awful for a thousand (didn’t scale). Or it can scale at O(1) to a million users but loading a page for even a single concurrent user can take 10 seconds (scales but doesn’t perform).</p>

<p>Like stated above, a traditional crud-style app on Rails can be made to scale very well by just adding app server instances, cores, and finally physical app servers serving the app. This is what is meant by scaling out<sup id="fnref:vs-up"><a href="#fn:vs-up" rel="footnote">2</a></sup>. Most often the limiting factor here is not Rails but the datastore, which is still often the one shared component in the equation. Scaling the database out is still harder than the appservers, but nevertheless possible. That is way outside the scope of this article, however.</p>

<h2 id="is-this-the-right-tool-for-the-job">Is this the right tool for the job?</h2>

<p>It’s clear in hindsight that a Rails app wasn’t the right tool for what Twitter became – a juggernaut where millions of people were basically realtime chatting with the whole world.</p>

<p>That doesn’t mean that Rails wasn’t a valid choice for the original app. Maybe it wasn’t the best option even then from the technical perspective, but it for sure made developing Twitter a whole lot faster in its initial stages. You know, twitter wasn’t the only contender in the microblogging stage in the late naughties. We finns fondly remember Jaiku. Then there was that other San Fransisco startup using Django that I can’t even name anymore.</p>

<p>Anyway, the point is that <em>reaching a scale where you have to think harder about scalability is a very, very nice problem to have</em>. Either you built a real business and are making money hand over fist, or you are playing – and winning – the eyeball lotto and have VCs knocking on your door (or, more realistically, have taken on several millions already). The vast majority of businesses <em>never</em> reach this stage.</p>

<p>More likely you just fail in the hockeystick game (the VC option), or perhaps build a sustainable business (the old-fashioned <em>people pay me for helping them kick ass</em> kind). In any case, you won’t have to worry about scaling to millions of concurrent users.</p>

<p>Even at the very profitable, high scale SaaS market there are hoards of examples of apps running on Rails. Kissmetrics runs its frontend on Rails, as does GitHub, not to mention Groupon, Livingsocial<sup id="fnref:ok-profitable"><a href="#fn:ok-profitable" rel="footnote">3</a></sup>, and many others.</p>

<p>However, at certain scale you have to go for a more modular architecture, SOA if I may. You can use a message queue for message passing, a noSQL db for non-relational and ephemeral data, node.js for realtime apps, and so on. <em>A good tool for every particular sub-task of your app</em>.</p>

<p>That said, you need to keep in mind what I said above. It is pretty unlikely you will ever reach a state where you really need to scale. Thus, thinking about the architecture at the initial stage too much is a form of premature optimization. As long as you don’t do anything extra stupid, you can probably get away with a simple Rails app. Because splitting up your app to lots of components early on makes several things harder and more expensive:</p>

<ul>
  <li>Complexity of development.</li>
  <li>Operating and deploying a bunch of different apps.</li>
  <li>Keeping track that all apps are up and running.</li>
  <li>Hunting bugs.</li>
  <li>Making changes in a lean development environment where things change rapidly</li>
  <li>Cognitive cost of understanding and learning how the app works. This is especially true when you’re expanding your team.</li>
</ul>

<p>This doesn’t mean that at some point you shouldn’t do the split. There might be a time where the scale for the points above tips, and a monorail app becomes a burden. But then again, <em>there might not</em>. So do what makes sense now, not what makes sense in your imaginary future.</p>

<p>Of <em>course</em> Rails alone won’t scale to a gazillion users for an app it wasn’t really meant for to begin with. Neither is it supposed to. However, it is amazing how far you can get with it, just the same way that the old boring PostgreSQL still beats the shit out of its more “modern” competitors in most common usecases<sup id="fnref:special-cases"><a href="#fn:special-cases" rel="footnote">4</a></sup>.</p>

<h2 id="questions-you-should-be-asking">Questions you should be asking</h2>

<p>When making a technology decision, instead of “Does is scale?”, here’s what you should be asking instead:</p>

<ul>
  <li>What is the right tool for the jobs of my app?</li>
  <li>How far can I likely get away with a single Rails app?</li>
  <li>Will we ever really reach the scale we claim in our investor prospectus? No need to lie to yourself here.</li>
  <li>What is more important: getting the app up and running and in front of real users fast, or making it scalable in an imaginary future that may never come?</li>
</ul>

<p>Only after answering those are you equipped to make a decision.</p>

<p>P.S. Reached the point where optimizing Rails and Ruby performance <em>does</em> make a difference? We’re writing <a href="https://bearmetal.eu/theden/categories/rails-performance/">a series of articles</a> about just that. Pop your details in the <a href="#mc_embed_signup">form ☟ down there</a> and we’ll keep you posted.</p>

<div class="footnotes">
  <ol>
    <li id="fn:marketing">
      <p>Another good one I heard in EuroOSCON 2005 was that the only thing good about Rails is its marketing.<a href="#fnref:marketing" rel="reference">&#8617;</a></p>
    </li>
    <li id="fn:vs-up">
      <p>Versus scaling up, which means making the single core or thread faster.<a href="#fnref:vs-up" rel="reference">&#8617;</a></p>
    </li>
    <li id="fn:ok-profitable">
      <p>OK, the last two might not pass the profitable bit.<a href="#fnref:ok-profitable" rel="reference">&#8617;</a></p>
    </li>
    <li id="fn:special-cases">
      <p>There are obviously special cases where a single Rails app doesn’t cut it even from the beginning. E.g. computationally intensive apps such as Kissmetrics or Skylight.io obviously won’t run their stats aggregation processes on Rails.<a href="#fnref:special-cases" rel="reference">&#8617;</a></p>
    </li>
  </ol>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails Garbage Collection: naive defaults]]></title>
    <link href="http://bearmetal.eu/theden/rails-garbage-collection-naive-defaults/"/>
    <updated>2014-12-04T17:27:00+02:00</updated>
    <id>http://bearmetal.eu/theden/rails-garbage-collection-naive-defaults</id>
    <content type="html"><![CDATA[<p><a href="https://www.flickr.com/photos/x1klima/13349077375/in/photolist-mkBvCt-9F5bop-psoHyh-6pkzNo-9uDMLx-85EMnZ-ibSsrK-iog9vf-JtxCJ-iohdxP-ibS242-7RtfVT-k1H87W-jNAG6M-oxaFaw-cR3ow7-gEqUsd-6z6KY5-e1m1pQ-diRWXG-i5md69-iogg32-ibSVHi-ibStrn-ibSVUy-n8CpB1-67QKGw-p3qtEX-4THpny-ebLNCE-nycgpC-6U69md-4yXv5b-pTDf3R-861fmQ-6zABJu-3FKVM-nwzafz-6pgrY2-9ejbm6-QuSM-hvn32M-aomUMi-9eebae-b15Lpi-8tBhZj-6o1Xmn-6z3YKz-5s868-61WvU1"><img src="https://farm8.staticflickr.com/7036/13349077375_36fc92ecce_k_d.jpg" alt="" /></a></p>

<p><small>Photo by <a href="https://www.flickr.com/photos/x1klima/13349077375/in/photolist-mkBvCt-9F5bop-psoHyh-6pkzNo-9uDMLx-85EMnZ-ibSsrK-iog9vf-JtxCJ-iohdxP-ibS242-7RtfVT-k1H87W-jNAG6M-oxaFaw-cR3ow7-gEqUsd-6z6KY5-e1m1pQ-diRWXG-i5md69-iogg32-ibSVHi-ibStrn-ibSVUy-n8CpB1-67QKGw-p3qtEX-4THpny-ebLNCE-nycgpC-6U69md-4yXv5b-pTDf3R-861fmQ-6zABJu-3FKVM-nwzafz-6pgrY2-9ejbm6-QuSM-hvn32M-aomUMi-9eebae-b15Lpi-8tBhZj-6o1Xmn-6z3YKz-5s868-61WvU1">martin</a>, used under the Creative Commons license.</small></p>

<p>The vast majority of <a href="http://www.rubyonrails.org">Ruby on Rails</a> applications deploy to production with the vanilla Ruby GC configuration. A conservative combination of growth factors and accounting that “works” for a demographic from IRB sessions (still my preferred calculator) to massive monolithic Rails apps (the fate of most successful ones). In practice this doesn’t work very well, however. It produces:</p>

<ul>
  <li>Too aggressive growth of Ruby heap slots and pages when thresholds are reached.</li>
  <li>A large ratio of short and medium lived objects in relation to long lived ones for Rails applications.</li>
  <li>Too many intermittent major GC cycles during the request / response cycle.</li>
  <li>Heap fragmentation.</li>
</ul>

<p>Let’s use a metaphor most of us can better relate to: <em>dreaded household chores.</em> Your ability and frequency of hosting dinners at home are limited by four things (takeaways and paper plates aside):</p>

<ul>
  <li>How many seats and tables you have</li>
  <li>How many sets of clean cutlery, plates and glasses are available</li>
  <li>Overhead preparing a particular choice of cuisine</li>
  <li>Willingness to clean up and do dishes after</li>
</ul>

<p>This is what you have to work with at home:</p>

<ul>
  <li>4 chairs and a table</li>
  <li>12 plates and equivalent utensils</li>
  <li>83 friends (60 from Facebook, 20 at work, your 2 brothers and then there’s Jim)</li>
  <li>3 wine glasses and a beer mug</li>
  <li>1 bottle of wine and 24 beers<sup id="fnref:promotions"><a href="#fn:promotions" rel="footnote">1</a></sup></li>
  <li>3 awesome steaks and a piece of tofu</li>
  <li>Fresh local produce</li>
</ul>

<p>Some of your friends are also vegetarian.</p>

<p>Let’s have a look at two different scenarios.</p>

<h4 id="irb-scenario">IRB scenario</h4>

<p>You’ve invited and subsequently prepared dinner and the table—seats, plates and cutlery sets—for four, popped open your bottle of wine and fired up the grill. However, only one friend arrives, quite late. You’re grilling steak number three, yet he’s the vegetarian…and only drinks beer. And even then doesn’t talk very much.</p>

<p>In the end, you down the whole bottle of wine and the three steaks. Life’s good again. There’s plenty to clean up and pack away, still.</p>

<h4 id="rails-scenario">Rails scenario</h4>

<p>17 guests show up at your door. Half of them are heavily intoxicated because Dylan invited the rest of his wine tasting group, too. Only one eats any of your food, yet breaks four plates. Beer disappeared in three minutes. The group members reveal seven new bottles of wine, make your dog drink one and he kernel panics as a result.</p>

<p>You were not f*cking prepared. At all. Marinated steak’s now ruined, there’s less inventory and 30+ bottles to recycle. You’re hungry and now there are no plates left!</p>

<p>In both of these scenarios, from the perspective of your friends it mostly worked out just fine. It wasn’t optimal for you or your environment, though. What’s important is that you learned a few things:</p>

<ul>
  <li>Next time it’s easier to execute optimally, but there may still be a party and some broken plates.</li>
  <li>A barbeque for 17 in your one bedroom flat with a George Foreman grill doesn’t scale well.</li>
</ul>

<h2 id="cooking-with-ruby">Cooking with Ruby</h2>

<p>In the same manner, different use cases for the Ruby runtime require different preparations. Let’s tie the dinner metaphor back to Ruby land and its memory model.</p>

<h4 id="home-environment">Home environment</h4>

<p>The Ruby runtime, with everything else inside. Pages, objects and auxilary object data.</p>

<h4 id="guest-count">Guest count</h4>

<p>The number of major features and facets you need to support. Gems and engines are good candidates along with individual models, controllers, views etc. These “seats” are also connected - different guests mingle together.</p>

<h4 id="guest-distribution">Guest distribution</h4>

<p>Rails provides a framework for building applications, thus should be considered as part of the guest list too. Like some family members that make their way to gettogethers. First and second tier cousins you may hear of once a year and never talk with - they’re present (consume memory), yet don’t always add much value to the ambient.</p>

<h4 id="food-and-drink">Food and drink</h4>

<p>The amount and distribution of objects required to make a feature or facet work. A mix bag of small entrees (embedded objects like 2-char strings), main dishes (a Rails request and all its context) to cocktails and tequila shots (threads!).</p>

<h4 id="plates-and-glasses">Plates and glasses</h4>

<p>An object slot on the Ruby heap. One String, Array, Hash or any other object. Keep in mind that they can overflow and be recycled too - a wine glass is good for multiple servings. For buffets, a single plate can go very far too :-)</p>

<h4 id="tables">Tables</h4>

<p>Ruby pages - containers for objects. All of the plates and glasses on a given table. They’re mostly prepared in advance, but you can “construct” and improvise as needed to.</p>

<h4 id="type-of-cuisine">Type of cuisine</h4>

<p>Some dishes incur a lot of work to prepare <em>and</em> to clean up. Cooked basmati rice will leave a very very different footprint in your kitchen than a paella or salmon option would.</p>

<p>The GC defaults for most Rails applications assume a reasonable sized home environment, a well defined guest list and just enough food and drinks for each. Everyone can sit at the same table, wine and dine on fine dishes, all with a minimal cleanup burden.</p>

<p><em>In reality, it’s a frat party. Gone seriously wrong.</em></p>

<p><em>In the next part of this series, we’re going to take a look at how the Ruby runtime can better host Rails applications. And what you can optimize for.</em></p>
<div class="footnotes">
  <ol>
    <li id="fn:promotions">
      <p>Because if there’s a promotion, you buy.<a href="#fnref:promotions" rel="reference">&#8617;</a></p>
    </li>
  </ol>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Metaprogramming Ruby for Greater Good]]></title>
    <link href="http://bearmetal.eu/theden/metaprogramming-ruby-for-greater-good/"/>
    <updated>2014-09-29T11:43:00+03:00</updated>
    <id>http://bearmetal.eu/theden/metaprogramming-ruby-for-greater-good</id>
    <content type="html"><![CDATA[<p><em>This is the transcript of the talk I gave in Reaktor Dev Day in Helsinki, September 26, 2014.</em> </p>

<script async="" class="speakerdeck-embed" data-id="89eb608027ae01321e4c624b84330d5d" data-ratio="1.77777777777778" src="http://bearmetal.eu//speakerdeck.com/assets/embed.js"></script>

<p>Thanks, and hi, everyone! It’s a real honor to be here. I’ve been a big fan of Reaktor for a long time, that is, UNTIL ALL MY GEEK FRIENDS DEFECTED THERE. There’s been lots of talk about Rosatom building a new nuclear plant here in Finland. I say fuck that, we already have enough nuclear knowledge locally. But I digress.</p>

<p>I’d like to be one of the cool kids and <em>Start with Why</em> just like Simon Sinek told us. However, before that it’s worth defining the term metaprogramming in the context of this talk.</p>

<p>What do we mean by metaprogramming? <em>In its simplest form, metaprogramming means code that writes code</em>.</p>

<p>A-ha! So, code generators are metaprogramming, too? Not really. I go with the definition where the code is generated on the fly in the runtime. We could perhaps call it dynamic metaprogramming. This means that most of what I’m going to talk about is not possible in a static language.</p>

<p>So a more appropriate definition might be, to quote Paolo Perrotta,</p>

<blockquote>
  <p>Writing code that manipulates language constructs at runtime.</p>
</blockquote>

<h2 id="why">Why?</h2>

<p>But why, I hear you ask. What’s in it for me? Well, first of all, because metaprogramming is…</p>

<p>…magic. And magic is good, right? Right? RIGHT? Well, it <em>can</em> be. At least it’s cool.</p>

<p>It’s also a fun topic for a conference like this, because it’s frankly, quite often, mind-boggling. Think of it like this. You take your brain out of your head. You put it in your backpocket. Then you sit on it. <em>Does it bend?</em> If it does, you’re talking about metaprogramming.</p>

<p>I also like things that make me scratch my head. I mean, scratching your head is a form of exercise. Just try it yourself. Scratch your head vigorously and your Fitbit will tell you you worked out like crazy today. That’s healthy.</p>

<p>But all joking aside, we don’t use metaprogramming to be clever, we use it to be flexible. And with Ruby – and any other sufficiently dynamic language – in the end of the day, <em>metaprogramming is just a fancy word for normal, advanced programming</em>.</p>

<h2 id="why-ruby">Why Ruby?</h2>

<p>So why Ruby? First of all, Ruby is the language I know by far the best. Second, Ruby combines Lisp-like dynamism and flexibility to a syntax that humans can actually decipher.</p>

<p>Like said, in Ruby there’s really no distinction between metaprogramming and advanced OO programming in general. Thus, before we go to things that are more literally metaprogramming, let’s have a look at Ruby’s object model and constructs that lay the groundwork for metaprogramming.</p>

<p>Thus, in a way, this talk can be reduced to <em>advanced OO concepts in Ruby</em>.</p>

<h2 id="how">How?</h2>

<p>Before we delve more deeply into the Ruby object model, let’s take a step back and have a look at what we mean by object-orientation.</p>

<p>Generally, there are two main approaches to object-oriented programming. By far the most popular is class-based OO, used in languages such as C++ and Java. The other one is prototype-based OO, which is most commonly seen in Javascript. So which of the two does Ruby use?</p>

<p>Class-based? Well, let’s have a look.</p>

<p>```ruby
  speaker = Object.new</p>

<p>def speaker.talk_length
    @talk_length ||= 30
  end</p>

<p>def speaker.talk_length=(length)
    @talk_length = length
  end
```</p>

<p>```ruby
  gary = speaker.clone
  gary.talk_length # =&gt; 30</p>

<p>gary.talk_length = 60
  gary.talk_length # =&gt; 60</p>

<p>scott = gary.clone
  scott.talk_length # =&gt; 60</p>

<p>scott.talk_length = 45
  scott.talk_length # =&gt; 45
```</p>

<p>How’s that for prototype-oriented OO in Ruby? But, noone does anything like this with Ruby. <em>No?</em> Just ask the DCI guys. Or, well, ask <a href="https://twitter.com/garybernhardt/status/514413978777563136">Gary about DCI (and Snuggies)</a>.</p>

<p>But I get your point, mainly when you do Ruby programming, you use something that resembles more the good ole class-based OO model. However, in Ruby it comes with a twist – or a dozen.</p>

<h3 id="everything-is-executable">Everything is executable</h3>

<p>```ruby</p>

<p>class Conference
  puts “Hello world (open)”</p>

<p>def venue
  end</p>

<p># …
end</p>

<h1 id="hello-world-open">Hello world (open)</h1>
<p># =&gt; nil
```</p>

<p>In Ruby, everything is executable, even the class definitions. But it doesn’t end there. What does the following produce?</p>

<p>```ruby</p>

<p>class Conference &lt; Event
end</p>

<p>```</p>

<p><code>
  &gt; c = Conference.new
  &gt; c.class
  =&gt; Conference
  &gt; c.class.superclass
</code></p>

<p>Event? Let’s see.</p>

<p>```ruby</p>

<p>class Conference &lt; Event
end</p>

<p>```</p>

<p><code>
  &gt; c = Conference.new
  &gt; c.class
  =&gt; Conference
  &gt; c.class.superclass
  =&gt; ChunkyBacon
</code></p>

<p>Bet you didn’t see that coming. Ok, I’ll admit, I hid something out of the original listing.</p>

<p>```ruby</p>

<p>class ChunkyBacon
end</p>

<p>Event = ChunkyBacon</p>

<p>class Conference &lt; Event
end
```</p>

<p><code>
  &gt; c = Conference.new
  &gt; c.class
  =&gt; Conference
  &gt; c.class.superclass
  =&gt; ChunkyBacon
</code></p>

<p>Remember, everything is executable. Thus, this would be just as valid:</p>

<p>```ruby</p>

<p>def gimme_a_class
  [Array, Hash, String][rand(3)]
end</p>

<p>class Conference &lt; gimme_a_class()
end
```</p>

<p>Stupid? Yes, but valid nonetheless.</p>

<h3 id="open-classes">Open classes</h3>

<p>In Ruby, you can open any class, even the built-in classes, to modify it. This is something that is called monkey-patching, or <a href="http://www.paulirish.com/2010/duck-punching-with-jquery/">duck punching</a> for extra giggles.</p>

<p>```ruby
class String
  alias_method :old_reverse, :reverse
  def reverse
    old_reverse.upcase
  end
end</p>

<blockquote>
  <p>speaker = “Gary”
speaker.reverse
=&gt; “YRAG”
```</p>
</blockquote>

<h3 id="everything-is-an-object">Everything is an Object</h3>

<p>Even methods. Thus you can even do functional style programming with Ruby. Think about it, you can use your favorite language to cook a delicious meal of callback spaghetti. Believe me, I’ve tried.</p>

<p><code>
&gt; String.instance_method(:reverse)
=&gt; #&lt;UnboundMethod: String#reverse&gt;
</code></p>

<h3 id="classes-are-objects-too">Classes are Objects, too</h3>

<p><em>Wait, what?</em></p>

<p>But, classes are different, I hear you say. They have class methods, and stuff.</p>

<p>I’ll let you into a secret. In Ruby, class methods are just like Ukraine in docent Bäckman’s rethoric: they don’t really exist. Wanna proof?</p>

<p><code>ruby
class Conference
  def self.in_finland
    # return conferences in Finland
  end
end
</code></p>

<p>Here’s an example of a class method in Ruby. Self is the current object, which in the case of a class definition is the class itself. Does this look familiar?</p>

<p>It should.</p>

<h3 id="singleton-methods">Singleton Methods</h3>

<p><code>ruby
  def speaker.talk_length
	@talk_length ||= 30
  end
</code></p>

<p>Singleton methods are methods that are defined for a single object, not for the whole object class.</p>

<h3 id="ruby-method-lookup">Ruby method lookup</h3>

<p><img src="/images/c3ba7a9122156b8a63f17a9ea1744800.png" alt="" /></p>

<p>Above is a simple (and pretty, huh?) diagram of Ruby method lookup. Methods reside in the object’s class, right of the object in the image. But where do singleton methods live? They can’t sit in the class, since then they’d be shared by all the objects of the same class. Neither can they be in the Object class, for the same reason.</p>

<p>Turns out they live in something called a singleton class.</p>

<h3 id="singleton-class">Singleton class</h3>

<p><img src="/images/1900b9d0d3a8368f8e56c39d8fc8ebc1.png" alt="Singleton classes in Ruby" /></p>

<p>Singleton class, a.k.a ghost class, metaclass, or eigenclass, is a special case of a class. It’s a regular class except for a couple of details:</p>

<ul>
  <li>It’s hidden from the generic class hierarchy. Thus e.g. the <code>#ancestors</code> method for a class never lists singleton classes.</li>
  <li>It cannot be directly inherited.</li>
  <li>It only ever has a single instance.</li>
</ul>

<p>So, what are class methods? They’re simply singleton methods for the class object itself. And like all singleton methods, they live in the singleton class of the object in question – in this case, the class object. <em>Because classes are just objects themselves</em>.</p>

<p><img src="/images/05cdd010de1fdf3005147e905f3c9ed7.png" alt="" /></p>

<p>This has an interesting corollary. Singleton classes are classes, and classes are objects, so…</p>

<p>…wait for it…</p>

<p>…a singleton class must have its own singleton class as well.</p>

<p>That’s right, it’s turtles…errr…singleton classes all the way down. Is it starting to feel like metaprogramming already? We have barely started.</p>

<h3 id="generating-code-dynamically-in-ruby">Generating Code Dynamically in Ruby</h3>

<p>We’re going to have a look at four different ways to generate code dynamically in Ruby:</p>

<ul>
  <li><code>eval</code></li>
  <li><code>instance_eval</code> &amp; <code>class_eval</code></li>
  <li><code>define_method</code></li>
  <li><code>method_missing</code></li>
</ul>

<h3 id="eval"><code>eval</code></h3>

<p><code>ruby
  meth = "my_method"
  eval &lt;&lt;-END
    def #{meth}
      "foo"
    end
  END
</code></p>

<p>Eval is the simplest and barest way to dynamically execute code in Ruby. It takes a string of code and then executes it in the current scope. You can also give eval an explicit scope using a <a href="http://www.ruby-doc.org/core-2.1.3/Binding.html">binding object</a> as the second argument.</p>

<p><code>ruby
def get_binding(a)
  binding
end
eval('a+1', get_binding(3)) # =&gt; 4, because 'a' in the context of get_binding is 3
</code></p>

<p>Eval is super powerful, but has a few huge drawbacks:</p>

<ul>
  <li>It messes up syntax highlighting and autocompletion since the code is just a string as far as the editor goes.</li>
  <li>It is a giant attack vector for code injection, unless you carefully make sure that no user-submitted data is passed to eval.</li>
</ul>

<p>For these reasons eval has slowly fallen out of favor, but there are still some cases where you have to drop down to bear metal (excuse the pun) means. As a rule of thumb however, you should as a first option resort to one of the following constructs.</p>

<h3 id="instanceeval"><code>instance_eval</code></h3>

<p>Put simply, <code>instance_eval</code> takes a block of code and executes it in the context of the receiving object. It can – just like <code>eval</code> – take a string, but also a real code block:</p>

<p><code>ruby
obj.instance_eval do
  self # =&gt; obj
  @v # =&gt; obj's instance var
end
</code></p>

<p>For the reasons above, you should probably use a code block with <code>instance_eval</code> instead of a string of code, unless you know what you’re doing and have a good reason for your choice.</p>

<p>A very common usecase for <code>instance_eval</code> is to build domain-specific languages.</p>

<p>```ruby
class Turtle
  def move(&amp;block)
    instance_eval(&amp;block)
  end</p>

<p>def right(n); end;
  def left(n); end;
  def up(n); end;
  def down(n); end;
end</p>

<p>t = Turtle.new
t.move do
  right(3)
  up
  left(2)
  down
end
```</p>

<h3 id="classeval"><code>class_eval</code></h3>

<p><code>class_eval</code> is the sister method for <code>instance_eval</code>. It changes the scope to inside the class definition of the used class. Thus, unlike <code>instance_eval</code>, it can only be called for classes and modules.</p>

<p>Because of this, a bit counterintuitively methods defined inside <code>class_eval</code> will become instance methods for that class’s objects, while methods defined inside <code>ClassName.instance_eval</code> will become its class methods.</p>

<p><code>ruby
[String, Array, Hash].each do |cls|
  cls.class_eval { include HelloWorld }
end
</code></p>

<h3 id="definemethod"><code>define_method</code></h3>

<p><code>define_method</code> is the most straightforward and highest-level way to dynamically create new methods. It is just the same as using the normal def syntax, except:</p>

<ul>
  <li>With <code>define_method</code> you can set the method name dynamically.</li>
  <li>You pass a block to <code>define_method</code> as the method body.</li>
</ul>

<p><code>ruby
class Cat &lt; Animal
  [:leg, :head, :tail].each do |part|
    define_method(part) do
      # …
    end
  end
end
</code></p>

<p>It is worth noting that you often use both <code>*_eval</code> and <code>define_method</code> together, e.g. when defining class methods.</p>

<p><code>ruby
class Cat &lt; Animal
  instance_eval do
    [:total_number, :sum_of_legs].each do |calc|
      define_method(calc) do
        # creates a class method, such as Cat.total_number
      end
    end
  end
end
</code></p>

<h3 id="methodmissing"><code>method_missing</code></h3>

<p><code>method_missing</code> is a special case of dynamic code in Ruby in that it doesn’t just by itself generate any dynamic code. However, you can use it to catch method calls that otherwise would go unanswered.</p>

<p><code>method_missing</code> is called for an object when the called method is not found in either the object’s class or any of its ancestors. By default <code>method_missing</code> raises a <code>NoMethodError</code>, but you can redefine it for any class to work as you need it to.</p>

<p>```ruby
class Speaker
  def method_missing(met, *args)
    if met.to_s == “speak”
      “I might as well say something: #{args[0]}”
    else
      super
    end
  end<br />
end</p>

<p>gary = Speaker.new
gary.talk(“Destroy it”) # =&gt; NoMethodError
gary.speak(“Just destroy it!”)
  # =&gt; “I might as well say something: Just destroy it!”
```</p>

<p><code>method_missing</code> is an example of a hook method in Ruby. Hook methods are similar to event handlers in Javascript in that they are called whenever a certain event (such as an unanswered method call above) happens during runtime. There are a bunch of hook methods in Ruby, but we don’t have time to dive deeper into them during this talk.</p>

<p><code>method_missing</code> differs from the previous concepts in this talk in that it doesn’t by itself generate new methods. This has two implications:</p>

<ul>
  <li>You don’t need to know the name of potentially called methods in advance. This can be very powerful in e.g. libraries that talk to external APIs.</li>
  <li>You can’t introspect the methods caught by <code>method_missing</code>. This means that e.g. <code>#instance_methods</code> won’t return the “ghost methods” that only <code>method_missing</code> catches. Likewise, <code>#respond_to?</code> will return false regardless of whether <code>method_missing</code> would have caught the call or not, unless you also overwrite the <a href="http://ruby-doc.org/core-2.1.3/Object.html#method-i-respond_to_missing-3F"><code>respond_to_missing?</code></a> method to be aware of the ghost method.</li>
</ul>

<h3 id="example-attraccessor-rewritten-in-ruby">Example: <code>attr_accessor</code> Rewritten in Ruby</h3>

<p>To top off this talk, we’re going to combine the topics we have learned so far to do a simple exercise. Namely, we’re going to rewrite a simple Ruby language construct ourself, in pure Ruby.</p>

<p>Ruby  has a simple construct called <code>attr_accessor</code> that creates getter and setter methods for named instance variables of the class’s object.</p>

<p>```ruby
class Animal
  attr_accessor :legs, :diet
end</p>

<p>cat = Animal.new
cat.legs = 4
cat.legs # =&gt; 4
cat.diet = “Small birds”
cat.diet # =&gt; “Small birds”
```</p>

<p>While <code>attr_accessor</code> above looks like some kind of keyword, it is actually just a call to a class method<sup id="fnref:instance"><a href="#fn:instance" rel="footnote">1</a></sup>. Remember, the whole class definition is executable code and <code>self</code> inside the class definition is set to the class itself. Thus, the line is the same as:</p>

<p><code>ruby
Animal.attr_accessor :legs, :diet
</code></p>

<p>So, how to add the method to the class?</p>

<p>```ruby
  class Animal
    def self.nattr_accessor(*meths)
      meths.each do |meth|
        # getter
        define_method(meth) do
          instance_variable_get(“@#{meth}”)
        end</p>

<pre><code>    # setter
    define_method("#{meth}=") do |wut|
      instance_variable_set("@#{meth}", wut)
    end
  end
end   end ```
</code></pre>

<p>In the code above we define a new class method, <code>nattr_accessor</code><sup id="fnref:collision"><a href="#fn:collision" rel="footnote">2</a></sup>. Then we iterate over all the method names the method is called with<sup id="fnref:asterisk"><a href="#fn:asterisk" rel="footnote">3</a></sup>. For each method, we use <code>define_method</code> twice, to generate both the getter and setter methods. Inside them, we use the <code>instance_variable_get</code> and <code>instance_variable_get</code> methods to dynamically get and set the variable value. Using these methods we can again avoid having to evaluate a string of code, the way as with using <code>define_method</code>.</p>

<p>Let’s now take a look whether our code works:</p>

<p>```ruby</p>

<p>class Cat &lt; Animal
    nattr_accessor :legs, :diet
  end</p>

<p>c = Cat.new
  c.legs = 4
  c.diet = “Small birds”
  c.legs # =&gt; 4
  c.diet # =&gt; “Small birds”
```</p>

<p>But what if we want to make the method more reusable? Where should it go then?</p>

<p>We could obviously put it into the <code>Object</code> class:</p>

<p>```ruby
  class Object
    def self.nattr_accessor(*meths)
      meths.each do |meth|
        # getter
        define_method(meth) do
          instance_variable_get(“@#{meth}”)
        end</p>

<pre><code>    # setter
    define_method("#{meth}=") do |wut|
      instance_variable_set("@#{meth}", wut)
    end
  end
end   end ```
</code></pre>

<p>But what if we don’t want it everywhere, cluttering the inheritance chain? Let’s put it in a module and reuse it where needed.</p>

<p>```ruby
  module Nattr
    def nattr_accessor(*meths)
      meths.each do |meth|
        # getter
        define_method(meth) do
          instance_variable_get(“@#{meth}”)
        end</p>

<pre><code>    # setter
    define_method("#{meth}=") do |wut|
      instance_variable_set("@#{meth}", wut)
    end
  end
end   end ```
</code></pre>

<p>Now we can use it our class:</p>

<p>```ruby
class Animal
  include Nattr
  nattr_accessor :legs, :heads
end</p>

<h1 id="nomethoderror-undefined-method-nattraccessor-for-animalclass">=&gt; NoMethodError: undefined method `nattr_accessor’ for Animal:Class</h1>
<p>from (pry):63:in <code>&lt;class:Animal&gt;'
</code>``</p>

<p>Oops. What happened?</p>

<p>We used include to get the Nattr module into Animal. However, include will take the methods in the module and make them <em>instance methods</em> of the including class. However, we need the method as a class method. What to do?</p>

<p>Fortunately, Ruby has a similar method called <code>extend</code>. It works the same way as include, except that it makes the methods from the module class methods<sup id="fnref:technically"><a href="#fn:technically" rel="footnote">4</a></sup> of our Animal class.</p>

<p>```ruby
class Animal
  extend Nattr
end</p>

<p>class Cat &lt; Animal
  nattr_accessor :legs, :diet
end</p>

<p>c = Cat.new
c.legs = 4
c.diet = “Mice”
c.legs
c.diet
```</p>

<p><em>Now we’re talking.</em></p>

<h3 id="problems-with-metaprogramming">Problems with metaprogramming</h3>

<p>Lemme tell you a story. About a dozen or so years ago I was living in Zürich, as an exchange student. I hadn’t yet found a permanent apartment so I was living at some friends’ place while they were abroad. A permanent internet connection wasn’t an ubiquitous thing back then, and the Swiss aren’t big into tv’s, so I had to figure out things to do at nights. I was living alone, and as a somewhat geeky guy I wasn’t that much into social life. Thus, I mostly read at nights. I had just found this <a href="http://www.joelonsoftware.com">Joel guy and a shitload of his writings</a>, so I used the printers at the university to print on the thin brownish paper (hey, it was free!) his somewhat ranting articles and then spent nights reading about <a href="http://www.joelonsoftware.com/articles/CamelsandRubberDuckies.html">camels and rubber duckies</a>, the <a href="http://www.joelonsoftware.com/articles/fog0000000043.html">Joel test</a>, – and <a href="http://www.joelonsoftware.com/articles/LeakyAbstractions.html">leaky abstractions</a>. And that is what metaprogramming in many cases is: an abstraction.</p>

<p>Now, there is nothing inherently wrong with abstractions – otherwise we’d all be programming in Assembler – but we’ll have to keep in mind that they always come at a cost. So keep in mind that metaprogramming is a super powerful tool to reduce duplication and to add power to your code, but you do have to pay a price for it.</p>

<p>Using too much metaprogramming, your code can become harder to:</p>

<ul>
  <li>read,</li>
  <li>debug, and</li>
  <li>search for.</li>
</ul>

<p>So use it as any powerful but potentially dangerous tool: start simply but when the complexity gets out of hand, sprinkle some metaprogramming magic dust to get back on the driver’s seat. Never use metaprogramming just for the sake of metaprogramming.</p>

<p>As Dave Thomas once said:</p>

<blockquote>
  <p>“The only thing worth worrying about when looking at code is ‘is it easy to change?’”</p>
</blockquote>

<p>Keep this in mind. Will metaprogramming make your code easier to change in this particular case? If yes, go for it. If not, don’t bother.</p>

<h3 id="where-now">Where now?</h3>

<p>We’ve only had time to scratch the surface of Ruby object model and metaprogramming. It’s a fractal of sometimes mind-boggling stuff, which also makes it so interesting. If you want to take the next steps in you advanced Ruby object model and metaprogramming knowledge, I’d recommend checking out the following:</p>

<ul>
  <li><a href="https://pragprog.com/screencasts/v-dtrubyom/the-ruby-object-model-and-metaprogramming">Dave Thomas’s screencasts at Prag Prog</a>. They’re a bit dated as in they cover Ruby 1.8. However, <em>not that much</em> has changed since then. Watching them also makes you feel good because you can see the great Prag Dave use Textmate, make mistakes, and delete characters in the code one by one.</li>
  <li>Paolo Perrotta’s <a href="https://pragprog.com/book/ppmetr2/metaprogramming-ruby-2">Metaprogramming Ruby</a> was just updated to cover the latest Ruby and Rails versions. It’s a very down-to-earth and easy read of a sometimes intimidating subject.</li>
  <li>If you already think you know everything about the subject, I’d recommend checking out Pat Shaughnessy’s <a href="http://patshaughnessy.net/ruby-under-a-microscope">Ruby Under a Microscope</a>. It goes down to the level of how the Ruby object model is implemented in C (yeah, really), while still being an entertaining read.</li>
  <li>Last but not least, read the source, Luke. Any non-trivial Ruby application is bound to have more than its share of metaprogramming sprinkled into it. Because, <strong>in Ruby, metaprogramming is just programming.</strong></li>
</ul>

<div class="footnotes">
  <ol>
    <li id="fn:instance">
      <p>Yeah, I know, singleton method of the class itself.<a href="#fnref:instance" rel="reference">&#8617;</a></p>
    </li>
    <li id="fn:collision">
      <p>Let’s name it something other than the built-in method just to avoid name collisions and nasty surprises.<a href="#fnref:collision" rel="reference">&#8617;</a></p>
    </li>
    <li id="fn:asterisk">
      <p>The asterisk before the parameter name means that we can have a number of arguments, each of which will be passed to the method in an array called <code>meths</code>.<a href="#fnref:asterisk" rel="reference">&#8617;</a></p>
    </li>
    <li id="fn:technically">
      <p>Technically, it opens up the singleton class of the Animal class and throws the methods in there. Thus they’ll become singleton methods for the Animal class, just like we want them to.<a href="#fnref:technically" rel="reference">&#8617;</a></p>
    </li>
  </ol>
</div>
]]></content>
  </entry>
  
</feed>
