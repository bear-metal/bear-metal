<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Osx | Bear Metal]]></title>
  <link href="https://bearmetal.eu/theden/categories/osx/atom.xml" rel="self"/>
  <link href="https://bearmetal.eu/"/>
  <updated>2018-02-12T07:00:00+02:00</updated>
  <id>https://bearmetal.eu/</id>
  <author>
    <name><![CDATA[Bear Metal OÜ]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Hosted Mender Getting Started on OSX and Raspberry Pi 3]]></title>
    <link href="https://bearmetal.eu/theden/hosted-mender-getting-started-on-osx-and-raspberry-pi-3/"/>
    <updated>2018-02-12T07:00:00+02:00</updated>
    <id>https://bearmetal.eu/theden/hosted-mender-getting-started-on-osx-and-raspberry-pi-3</id>
    <content type="html"><![CDATA[<p>Having various embedded linux devices around (mostly Raspberry Pi&rsquo;s), and a few client projects dealing with software updates to remote devices, I&rsquo;ve become interested in fleet management. More specifically, I wanted:</p>

<ul>
<li>inventory management</li>
<li><a href="https://source.android.com/devices/tech/ota/ab/">A/B partition updates</a></li>
<li>integrity checks</li>
<li>signed updates</li>
</ul>


<p>I&rsquo;ve heard about <a href="https://resin.io/">resin.io</a> before, and while appealing, the control freak in me wanted something with an open server infrastructrure. I&rsquo;m also not sold on having docker in production embedded devices (while surely being useful for prototyping and experimentation).</p>

<p>Then there&rsquo;s the <a href="https://nerves-project.org">nerves project</a>, mostly focused around the elixir ecosystem. Something I definitely want to check out in more detail, both to learn more about elixir and for simpler embedded projects.</p>

<p>Then I stumbled onto <a href="https://mender.io/">mender</a>. On first glance, it seems perfect. Let&rsquo;s take a look, shall we?</p>

<h1>Burning the initial image</h1>

<p>We&rsquo;re gonna be roughly following along the <a href="https://docs.mender.io/1.3/getting-started">mender getting started guide</a> while keeping things OSX compatible.</p>

<p>Instead of running our own server infrastructure (which is nice to have as an option, but not required for initial experimenting), we&rsquo;ll be using <a href="https://hosted.mender.io/">hosted mender</a>. That means we will have to inject our hosted mender token into the initial disk image what we will boot the RPi3 from.</p>

<p>Download the Raspberry Pi 3 disk image from <a href="https://docs.mender.io/1.3/getting-started/download-test-images">https://docs.mender.io/1.3/getting-started/download-test-images</a> .
Decompress and change the file extension to make it palatable for <code>hdiutil</code>.
<code>bash
wget https://d1b0l86ne08fsf.cloudfront.net/1.3.1/raspberrypi3/mender-raspberrypi3_1.3.1.sdimg.gz
gunzip mender-raspberrypi3_1.3.1.sdimg.gz
  mv mender-raspberrypi3_1.3.1.sdimg mender-raspberrypi3_1.3.1.img
</code></p>

<p>Verify we have a good image
<code>bash
hdiutil imageinfo mender-raspberrypi3_1.3.1.img
</code></p>

<pre><code class="bash">Backing Store Information:
    URL: file:///Users/erkkieilonen/projects/learning/mender/mender-raspberrypi3_1.3.1.img
    Name: mender-raspberrypi3_1.3.1.img
    Class Name: CBSDBackingStore
Class Name: CRawDiskImage
Checksum Type: none
Size Information:
    Total Bytes: 624951296
    Compressed Ratio: 1
    Sector Count: 1220608
    Total Non-Empty Bytes: 624951296
    Compressed Bytes: 624951296
    Total Empty Bytes: 0
Format: RAW*
Format Description: raw read/write
Checksum Value:
Properties:
    Encrypted: false
    Kernel Compatible: true
    Checksummed: false
    Software License Agreement: false
    Partitioned: false
    Compressed: no
Segments:
    0: /Users/erkkieilonen/projects/learning/mender/mender-raspberrypi3_1.3.1.img
partitions:
    partition-scheme: fdisk
    block-size: 512
    partitions:
        0:
            partition-name: Master Boot Record
            partition-start: 0
            partition-synthesized: true
            partition-length: 1
            partition-hint: MBR
            boot-code: 0xFAB800108ED0BC00B0B800008ED88EC0FBBE007CBF0006B90002F3A4EA21060000BEBE073804750B83C61081FEFE0775F3EB16B402B001BB007CB2808A74018B4C02CD13EA007C0000EBFE0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000A31D6D430000
        1:
            partition-name:
            partition-start: 1
            partition-synthesized: true
            partition-length: 24575
            partition-hint: Apple_Free
        2:
            partition-start: 24576
            partition-number: 1
            partition-length: 81920
            partition-hint: Windows_FAT_32
            partition-filesystems:
                FAT16: boot
        3:
            partition-start: 106496
            partition-number: 2
            partition-length: 425984
            partition-hint: Linux_Ext2FS
        4:
            partition-start: 532480
            partition-number: 3
            partition-length: 425984
            partition-hint: Linux_Ext2FS
        5:
            partition-start: 958464
            partition-number: 4
            partition-length: 262144
            partition-hint: Linux_Ext2FS
    burnable: false
Resize limits (per hdiutil resize -limits):
 min     cur     max
1220608 1220608 1245311712
</code></pre>

<p>We can see the boot partition, the primary and secondary root partitions and the data partition.
Since the root partitions are using ext2fs, and we&rsquo;re on OSX, we need to install <a href="https://osxfuse.github.io">FUSE for macOS</a> along with <a href="https://github.com/alperakcan/fuse-ext2">FUSE-Ext2</a> to be able to mount and write to these partitions.</p>

<h2>FUSE for macOS</h2>

<p>Download the OSX package from <a href="https://osxfuse.github.io">https://osxfuse.github.io</a> and follow the instructions to install it. Make sure to tick the checkbox for <code>MacFUSE Compatibility Layer</code>. That&rsquo;s required for <code>FUSE-Ext2</code>  support.</p>

<h2>FUSE-Ext2</h2>

<p>This gets a little more complicated.
Instead of compiling everything from source, like described <a href="https://github.com/alperakcan/fuse-ext2#mac-os">here</a>, we&rsquo;re using the excellent <a href="https://brew.sh">Homebrew</a> package manager to install the dependencies and just compile <code>FUSE-Ext2</code> itself. (we should probably create a formula for FUSE-Ext2 too &hellip;)</p>

<p>Install the dependencies
<code>bash
brew install m4 autoconf automake libtool e2fsprogs
</code></p>

<p>Install <code>FUSE-Ext2</code> itself
<code>bash
git clone https://github.com/alperakcan/fuse-ext2.git
cd fuse-ext2
./autogen.sh
./configure
CFLAGS="-I /usr/local/include -I $(brew --prefix e2fsprogs)/include" LDFLAGS="-L/usr/local/lib -L$(brew --prefix e2fsprogs)/lib" ./configure
make
sudo make install
cd ..
</code></p>

<p>Attach the original mender image
<code>bash
hdiutil attach mender-raspberrypi3_1.3.1.img
</code></p>

<pre><code class="bash">/dev/disk2              FDisk_partition_scheme
/dev/disk2s1            Windows_FAT_32                  /Volumes/boot
/dev/disk2s2            Linux
/dev/disk2s3            Linux
/dev/disk2s4            Linux
</code></pre>

<p>Since <code>/dev/disk1</code> is our OSX boot disk, and we have nothing else mounted, <code>/dev/disk2</code> is the <code>.img</code> file we just attached. Pay attention to use the correct device in case you have more disks attached.</p>

<p>We will have to mount both of the root partitions and edit some files in there.</p>

<pre><code class="bash">mkdir $(e2label /dev/disk2s2)
mkdir $(e2label /dev/disk2s3)
mount -t fuse-ext2 -o rw /dev/disk2s2 $(e2label /dev/disk2s2)
mount -t fuse-ext2 -o rw /dev/disk2s3 $(e2label /dev/disk2s3)
</code></pre>

<p>Grab your <a href="https://hosted.mender.io">hosted mender</a> token (  top right menu, under <em>My organization</em>) and inject it to the image.
Replace <code>&lt;token from hosted mender&gt;</code> with your token.</p>

<pre><code class="bash">sed -ibak 's/dummy/&lt;token from hosted mender&gt;/' primary/etc/mender/mender.conf
sed -ibak 's/docker.mender.io/hosted.mender.io/' primary/etc/mender/mender.conf
sed -ibak 's/dummy/&lt;token from hosted mender&gt;/' secondary/etc/mender/mender.conf
sed -ibak 's/docker.mender.io/hosted.mender.io/' secondary/etc/mender/mender.conf
</code></pre>

<p>Verify the config file contents
<code>bash
cat primary/etc/mender/mender.conf
</code></p>

<pre><code class="bash">{
    "InventoryPollIntervalSeconds": 5,
    "RetryPollIntervalSeconds": 1,
    "RootfsPartA": "/dev/mmcblk0p2",
    "RootfsPartB": "/dev/mmcblk0p3",
    "ServerCertificate": "/etc/mender/server.crt",
    "ServerURL": "https://hosted.mender.io",
    "TenantToken": "&lt;token from hosted mender&gt;",
    "UpdatePollIntervalSeconds": 5
}
</code></pre>

<p>Unmount and burn the image and we&rsquo;re done. Adjust <code>/dev/disk3</code> to your sdcard device.</p>

<pre><code class="bash">umount primary
umount secondary
hdiutil detach /dev/disk2
sudo dd if=mender-raspberrypi3_1.3.1.img of=/dev/disk3 bs=1m &amp;&amp; sudo sync
hdiutil detach /dev/disk3
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Getting Vagrant VMware Plugin Installed on OS X El Capitan and Homebrew]]></title>
    <link href="https://bearmetal.eu/theden/getting-vagrant-vmware-plugin-installed-on-os-x-el-capitan-and-homebrew/"/>
    <updated>2015-10-26T11:18:37+02:00</updated>
    <id>https://bearmetal.eu/theden/getting-vagrant-vmware-plugin-installed-on-os-x-el-capitan-and-homebrew</id>
    <content type="html"><![CDATA[<p>I finally decided to bite the bullet this morning and install VMware Fusion 8 and the corresponding Vagrant plugin.</p>

<p>Both were paid upgrades (41.42€ + $39 from Fusion 7), which was a bit bitter given I had only had the previous versions for a couple of months. Yet, the word on the street was that the new version would be much more stable and less cpu-hungry than the previous generation. So what the heck, maybe I’d again be able to get more than a couple hours of productive work done without draining the battery.</p>

<p>The purchase process itself was painless, as was installing VMware itself. But when I started installing the plugin, an ugly yak raised its hairy head.</p>

<p>The first thing I tried was to just use the old plugin with the new VMware version. Would it perhaps work?</p>

<pre><code class="bash">    ➜  ~ vagrant suspend
    This provider only works with VMware Fusion 5.x, 6.x, or 7.x. You have
    Fusion '8.0.1'. Please install the proper version of VMware
    Fusion and try again.
</code></pre>

<p>That sounds like a resounding “No”.</p>

<p>So onwards: bought a license for the plugin as well and tried to install it.</p>

<pre><code class="bash">    ➜  ~ vagrant plugin install vagrant-vmware-fusion
    Installing the 'vagrant-vmware-fusion' plugin. This can take a few minutes...
    Bundler, the underlying system Vagrant uses to install plugins,
    reported an error. The error is shown below. These errors are usually
    caused by misconfigured plugin installations or transient network
    issues. The error from Bundler is:

    An error occurred while installing hitimes (1.2.3), and Bundler cannot continue.
    Make sure that `gem install hitimes -v '1.2.3'` succeeds before bundling.

    Gem::Installer::ExtensionBuildError: ERROR: Failed to build gem native extension.

        /opt/vagrant/embedded/bin/ruby extconf.rb 
    creating Makefile

    make "DESTDIR="


    Agreeing to the Xcode/iOS license requires admin privileges, please re-run as root via sudo.
</code></pre>

<p>No biggie, a little Googling revealed what I suspected – I don’t actually need to run this as root, I just need to accept the EULA of the latest XCode version before running the install process again. I popped up XCode, YOLOed the agreement, and was back to the terminal.</p>

<pre><code class="bash">    ➜  ~ vagrant plugin install vagrant-vmware-fusion
    Installing the 'vagrant-vmware-fusion' plugin. This can take a few minutes...
    Bundler, the underlying system Vagrant uses to install plugins,
    reported an error. The error is shown below. These errors are usually
    caused by misconfigured plugin installations or transient network
    issues. The error from Bundler is:

    An error occurred while installing eventmachine (1.0.8), and Bundler cannot continue.
    Make sure that `gem install eventmachine -v '1.0.8'` succeeds before bundling.

    Gem::Installer::ExtensionBuildError: ERROR: Failed to build gem native extension.

    [LOTS OF CRUFT REMOVED FOR BREVITY]

    make "DESTDIR="
    compiling binder.cpp
    warning: unknown warning option '-Werror=unused-command-line-argument-hard-error-in-future'; did you mean '-Werror=unused-command-line-argument'? [-Wunknown-warning-option]
    In file included from binder.cpp:20:
    ./project.h:116:10: fatal error: 'openssl/ssl.h' file not found
    #include &lt;openssl/ssl.h&gt;
             ^
    1 warning and 1 error generated.
    make: *** [binder.o] Error 1


    Gem files will remain installed in /Users/jarkko/.vagrant.d/gems/gems/eventmachine-1.0.8 for inspection.
    Results logged to /Users/jarkko/.vagrant.d/gems/gems/eventmachine-1.0.8/ext/gem_make.out
</code></pre>

<p>Again, the reason is clear: I need to build the gem against proper openssl libs – in this case, <code>-I/usr/local/opt/openssl/include</code>. Thus:</p>

<pre><code class="bash">    ➜  ~  gem install eventmachine -v '1.0.8' -- --with-cppflags=-I/usr/local/opt/openssl/include
    Fetching: eventmachine-1.0.8.gem (100%)
    Building native extensions with: '--with-cppflags=-I/usr/local/opt/openssl/include'
    This could take a while...
    Successfully installed eventmachine-1.0.8
    Parsing documentation for eventmachine-1.0.8
    Installing ri documentation for eventmachine-1.0.8
    Done installing documentation for eventmachine after 6 seconds
    1 gem installed
</code></pre>

<p>Perfect. So I tried to install the Vagrant plugin again – and got the same error. Crap.</p>

<p>It turns out that Vagrant uses its own gem folder, so it’s not picking up what’s installed in one’s primary gem directory. The issue was, how do I tell Vagrant to use the correct cpp flags in its build process?</p>

<p>Fortunately I didn’t have to figure that out, because the end of the error message above gave me enough of a pointer towards a solution: if I only managed to install the eventmachine gem by hand to the correct location with the proper cpp flags, I should be fine. But how?</p>

<p>I dug up to <code>gem -h</code> and the defaults at the end gave the correct option away: with the <code>--install-dir</code> option I could install the gem to wherever I wanted to. Thus:</p>

<pre><code class="bash">    ~  gem install eventmachine -v '1.0.8' --install-dir /Users/jarkko/.vagrant.d/gems  -- --with-cppflags=-I/usr/local/opt/openssl/include
    Fetching: eventmachine-1.0.8.gem (100%)
    Building native extensions with: '--with-cppflags=-I/usr/local/opt/openssl/include'
    This could take a while...
    Successfully installed eventmachine-1.0.8
    Parsing documentation for eventmachine-1.0.8
    Installing ri documentation for eventmachine-1.0.8
    Done installing documentation for eventmachine after 5 seconds
    1 gem installed
</code></pre>

<p>Et voilá. Now one more try:</p>

<pre><code class="bash">    ➜    vagrant plugin install vagrant-vmware-fusion
    …
    Installed the plugin 'vagrant-vmware-fusion (4.0.2)'!
</code></pre>

<p>…and we’re off to the races!</p>

<p>…well, at least almost.</p>

<pre><code class="bash">    ➜  ~ vagrant up
    Bringing machine 'default' up with 'vmware_fusion' provider...
    ==&gt; default: Verifying vmnet devices are healthy...
    ==&gt; default: Preparing network adapters...
    ==&gt; default: Starting the VMware VM...
    An error occurred while executing `vmrun`, a utility for controlling
    VMware machines. The command and output are below:

    Command: ["start", "/Users/jarkko/vmware/955a09a5-f7f6-451e-b565-22f41c8fced0/packer-ubuntu-14.04-amd64.vmx", "nogui", {:notify=&gt;[:stdout, :stderr], :timeout=&gt;45}]

    Stdout: 2015-10-26T11:10:45.943| ServiceImpl_Opener: PID 84443
    Error: The operation was canceled

    Stderr: 
</code></pre>

<p>Oh well, that wasn’t very helpful. So I tried the proven trick #1: I killed the VMware app on OS X and even its menubar daemon just to be certain, and sure enough, it did the trick. The vagrant VM is now back on track.</p>
]]></content>
  </entry>
  
</feed>
